<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Manfred的小屋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录每天的点点滴滴">
<meta property="og:type" content="website">
<meta property="og:title" content="Manfred的小屋">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Manfred的小屋">
<meta property="og:description" content="记录每天的点点滴滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Manfred的小屋">
<meta name="twitter:description" content="记录每天的点点滴滴">
  
    <link rel="alternative" href="/atom.xml" title="Manfred的小屋" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xsibp.com2.z0.glb.clouddn.com/manfred.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Manfred Zhao</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://github.com/manfredgithub" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/1882681071/home?wvr=5" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/#signin" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Linux学习总结/" style="font-size: 10px;">Linux学习总结</a> <a href="/tags/个人感悟/" style="font-size: 10px;">个人感悟</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">蜗居在帝都的小小程序猿</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Manfred Zhao</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xsibp.com2.z0.glb.clouddn.com/manfred.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Manfred Zhao</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://github.com/manfredgithub" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/1882681071/home?wvr=5" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/#signin" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="w-GDB调试工具总结" class="article article-type-w" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/17/GDB调试工具总结/" class="article-date">
  	<time datetime="2016-04-17T08:14:26.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/GDB调试工具总结/">GDB调试工具总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="GDB调试工具总结"><a href="#GDB调试工具总结" class="headerlink" title="GDB调试工具总结"></a>GDB调试工具总结</h3><p>程序调试的基本思想是“分析现象-&gt;假设错误原因-&gt;产生新的现象去验证假设”这样一个循环过程，根据现象如何假设错误原因，以及如何设计新的现象去验证假设，需要非常严密的分析和思考。程序中除了一目了然的Bug之外都需要一定的调试手段来分析到底错在哪，到目前为止自己使用过的调试手段只有一种：</p>
<blockquote>
<p>根据程序执行时的出错现象假设错误原因，然后在代码中适当的位置插入printf（驱动使用printk函数），执行程序并分析打印结果，如果结果和心里预期的一样，就基本上证明了自己假设的错误原因，就可以动手修正Bug了，如果结果和预期的不一样，就根据结果做进一步的假设和分析。</p>
</blockquote>
<p>printf这种方法对于小程序简单有效，面对一些较大的程序时难免有些力不从心。GDB是Unix/Linux下非常强大的程序调试工具，最近对其基本使用方法进行学习，做一下总结。</p>
<h6 id="1、gdb工具基本使用"><a href="#1、gdb工具基本使用" class="headerlink" title="1、gdb工具基本使用"></a>1、gdb工具基本使用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int add(int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int i,sum;</span><br><span class="line">    for(i=low;i&lt;=high;i++)</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int result[100];</span><br><span class="line">    result[0] = add(1,10);</span><br><span class="line">    result[1] = add(1,100);</span><br><span class="line">    printf(&quot;result[0] is %d\nresult[1] is %d \n&quot;,result[0],result[1]);  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将这段程序利用<figure class="highlight plain"><figcaption><span>gdb.c -o gdb ```进行编译，运行结果如下：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">``` </span><br><span class="line">[peterwang@localhost gdb]$ gcc gdb.c -o gdb</span><br><span class="line">[peterwang@localhost gdb]$ ./gdb </span><br><span class="line">result[0] is 11413250</span><br><span class="line">result[1] is 11418300 </span><br><span class="line">[peterwang@localhost gdb]$</span><br></pre></td></tr></table></figure></p>
<p>很明显打印出来的结果是错误的，程序完成的功能是计算1加到10和1加到100的和，打印出来的结果应该是55和5050（这个例子只是为了展示gdb的调试步骤，程序本身的问题很轻松就可以发现），下面利用gdb对程序进行调试。</p>
<p>利用gdb调试，需要在gcc编译过程中加上<figure class="highlight plain"><figcaption><span>```选项，这样编译生成的可执行文件才可以利用gdb进行源码调试。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>[peterwang@localhost gdb]$ gdb gdb<br>GNU gdb (GDB) Red Hat Enterprise Linux (7.2-83.el6)<br>Copyright (C) 2010 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later <a href="http://gnu.org/licenses/gpl.html" target="_blank" rel="external">http://gnu.org/licenses/gpl.html</a><br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.  Type “show copying”<br>and “show warranty” for details.<br>This GDB was configured as “i686-redhat-linux-gnu”.<br>For bug reporting instructions, please see:<br><a href="http://www.gnu.org/software/gdb/bugs/" target="_blank" rel="external">http://www.gnu.org/software/gdb/bugs/</a>…<br>Reading symbols from /home/peterwang/TestProgram/gdb/gdb…done.<br>(gdb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```-g``` 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。如果把当前的gdb.c改名为g.c或者将gdb.c移动到其他地方，则gdb无法进行调试。</span><br></pre></td></tr></table></figure></p>
<p>[peterwang@localhost gdb]$ mv gdb.c g.c<br>[peterwang@localhost gdb]$ gdb gdb<br>GNU gdb (GDB) Red Hat Enterprise Linux (7.2-83.el6)<br>Copyright (C) 2010 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later <a href="http://gnu.org/licenses/gpl.html" target="_blank" rel="external">http://gnu.org/licenses/gpl.html</a><br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.  Type “show copying”<br>and “show warranty” for details.<br>This GDB was configured as “i686-redhat-linux-gnu”.<br>For bug reporting instructions, please see:<br><a href="http://www.gnu.org/software/gdb/bugs/" target="_blank" rel="external">http://www.gnu.org/software/gdb/bugs/</a>…<br>Reading symbols from /home/peterwang/TestProgram/gdb/gdb…done.<br>(gdb) start<br>Temporary breakpoint 1 at 0x80483f5: file gdb.c, line 18.<br>Starting program: /home/peterwang/TestProgram/gdb/gdb </p>
<p>Temporary breakpoint 1, main (argc=1, argv=0xbffff324) at gdb.c:18<br>18    gdb.c: No such file or directory.<br>    in gdb.c<br>(gdb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb提供一个类似Shell的命令行环境，上面的(gdb)就是提示符，在这个提示符下输入```help```可以查看命令的类别：</span><br></pre></td></tr></table></figure></p>
<p>(gdb) help<br>List of classes of commands:</p>
<p>aliases – Aliases of other commands<br>breakpoints – Making program stop at certain points<br>data – Examining data<br>files – Specifying and examining files<br>internals – Maintenance commands<br>obscure – Obscure features<br>running – Running the program<br>stack – Examining the stack<br>status – Status inquiries<br>support – Support facilities<br>tracepoints – Tracing of program execution without stopping the program<br>user-defined – User-defined commands</p>
<p>Type “help” followed by a class name for a list of commands in that class.<br>Type “help all” for the list of all commands.<br>Type “help” followed by command name for full documentation.<br>Type “apropos word” to search for commands related to “word”.<br>Command name abbreviations are allowed if unambiguous.<br>(gdb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以看出来gdb的命令是分类的，利用```help 类别（比如 help data） ```可以进一步查看data类别下的命令帮助。 </span><br><span class="line"></span><br><span class="line">我们可以利用```list(简写为l)```命令列出当前程序的代码，默认列出10行，如果想列出更多，可以再次输入list，也可以直接敲击回车键，gdb有个很好用的功能，直接敲击回车键表示执行上一条命令。</span><br></pre></td></tr></table></figure></p>
<p>(gdb) list<br>9    {<br>10        int i,sum;<br>11        for(i=low;i&lt;=high;i++)<br>12            sum = sum + i;<br>13        return sum;<br>14    }<br>15    int main(int argc,char **argv)<br>16    {<br>17        int result[100];<br>18        result[0] = add(1,10);<br>(gdb)<br>19        result[1] = add(1,100);<br>20        printf(“result[0] is %d\nresult[1] is %d \n”,result[0],result[1]);<br>21        return 0;<br>22    }<br>(gdb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb调试工具需要首先用```start```命令开始执行程序，</span><br></pre></td></tr></table></figure></p>
<p>(gdb) start<br>Temporary breakpoint 1 at 0x80483f5: file gdb.c, line 18.<br>Starting program: /home/peterwang/TestProgram/gdb/gdb </p>
<p>Temporary breakpoint 1, main (argc=1, argv=0xbffff324) at gdb.c:18<br>18        result[0] = add(1,10);<br>(gdb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb停在main函数中变量定义之后的第一条语句处等待我们发命令， gdb列出的这条语句是即将执行</span><br><span class="line">的下一条语句。退出gdb调试环境可以利用```quit```命令</span><br></pre></td></tr></table></figure></p>
<p>(gdb) quit<br>A debugging session is active.</p>
<pre><code>Inferior 1 [process 3878] will be killed.
</code></pre><p>Quit anyway? (y or n) y<br>[peterwang@localhost gdb]$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">###### 2、单步执行和跟踪函数调用</span><br><span class="line"></span><br><span class="line">根据上一小节的介绍，我们已经知道如何进入gdb调试工具以及基本知识，本小节将通过gdb调试工具找出上一小节函数输出错误的原因。</span><br><span class="line"></span><br><span class="line">利用```start```命令开始gdb调试，我们可以看到程序停在了main函数的```result[0] = add(1,10);```这一行：</span><br></pre></td></tr></table></figure></p>
<p>[peterwang@localhost gdb]$ gdb gdb<br>GNU gdb (GDB) Red Hat Enterprise Linux (7.2-83.el6)<br>Copyright (C) 2010 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later <a href="http://gnu.org/licenses/gpl.html" target="_blank" rel="external">http://gnu.org/licenses/gpl.html</a><br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.  Type “show copying”<br>and “show warranty” for details.<br>This GDB was configured as “i686-redhat-linux-gnu”.<br>For bug reporting instructions, please see:<br><a href="http://www.gnu.org/software/gdb/bugs/" target="_blank" rel="external">http://www.gnu.org/software/gdb/bugs/</a>…<br>Reading symbols from /home/peterwang/TestProgram/gdb/gdb…done.<br>(gdb) start<br>Temporary breakpoint 1 at 0x80483f5: file gdb.c, line 18.<br>Starting program: /home/peterwang/TestProgram/gdb/gdb </p>
<p>Temporary breakpoint 1, main (argc=1, argv=0xbffff324) at gdb.c:18<br>18        result[0] = add(1,10);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面我们利用```next(简写为n)```命令控制程序向下执行：</span><br></pre></td></tr></table></figure></p>
<p>(gdb) n<br>19        result[1] = add(1,100);<br>(gdb)<br>20        printf(“result[0] is %d\nresult[1] is %d \n”,result[0],result[1]);<br>(gdb)<br>result[0] is 1218306<br>result[1] is 1223356<br>21        return 0;<br>(gdb)<br>22    }<br>(gdb)<br><strong>libc_start_main (main=0x80483e9 <main>, argc=1, ubp_av=0xbffff324, init=0x8048460 &lt;</main></strong>libc_csu_init&gt;, fini=0x8048450 <__libc_csu_fini>, rtld_fini=0x11f4c0 <_dl_fini>, stack_end=0xbffff31c) at libc-start.c:258<br>258      exit (result);<br>(gdb) </_dl_fini></__libc_csu_fini></p>
<p>Program exited normally.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虽然程序正常打印，并且显示正常退出，可以并没有找到程序的问题所在。重新运行```start```命令，利用```step(简写s)```跳入add(1,10)函数中进行调试，在add()函数中利用```backtrace(简写为bt```命令查看函数调用的栈帧：</span><br></pre></td></tr></table></figure></p>
<p>(gdb) start<br>Temporary breakpoint 2 at 0x80483f5: file gdb.c, line 18.<br>Starting program: /home/peterwang/TestProgram/gdb/gdb </p>
<p>Temporary breakpoint 2, main (argc=1, argv=0xbffff324) at gdb.c:18<br>18        result[0] = add(1,10);<br>(gdb) s<br>add (low=1, high=10) at gdb.c:11<br>11        for(i=low;i&lt;=high;i++)<br>(gdb) bt</p>
<p>#0  add (low=1, high=10) at gdb.c:11</p>
<p>#1  0x08048409 in main (argc=1, argv=0xbffff324) at gdb.c:18<br>(gdb) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以看出函数add()被main()函数调用，main传进来的参数是low=1,high=10。main函数的栈帧编号为1， add_range的栈帧编号为0。现在可以利用```info(简写为i)```查看add()函数中局部变量的值：</span><br></pre></td></tr></table></figure>
<p>(gdb) i locals<br>i = 1224252<br>sum = 1218251<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以看到当前add()函数中变量```i```和变量```sum```为很大的数，看到这里基本就可以猜出程序错误是由于```i```和```sum```未进行初始化导致。  </span><br><span class="line">如果想查看main函数当前局部变量的值也可以做到，先用```frame(简写为f)```选择1号栈帧然后再查看局部变量：</span><br></pre></td></tr></table></figure></p>
<p>(gdb) frame 1</p>
<p>#1  0x08048409 in main (argc=1, argv=0xbffff324) at gdb.c:18<br>18        result[0] = add(1,10);<br>(gdb) i locals<br>result = {136, 1241028, 0, 1114836, 1114932, 7, 0, 1114112, 0, 1152850, 1325276, 134513214, -1207961936, -1208025086, 1177933, 134513164, 1244128, 1241028, 1264592, 1, -1073745444, 1154825, 61145, 1241028, -1073745288, 1128753,<br>  1242396, 1243824, 0, 0, 0, 0, 0, 0, 0, 0, -1207961984, 0, 1245544, 1265112, 1223968, -1073745500, 1300312, 14, 129100401, -1207961984, -163754450, 0, 3, 1243384, 0, 0, 1, 2200, -1207961936, -1207962672, 134513196, 1302392,<br>  134513100, 1, 1241028, -1073745200, 1243824, -1073745244, 1155338, -1073745260, 134513100, -1073745272, 1243732, 0, -1207961936, 1, 0, 1, 1243384, 1, 13238272, 0, 15773951, 1, 194, 16372, 2892252, 0, -1073745200, 134518456,<br>  -1073745336, 134513344, 6291456, 134518456, -1073745288, 134513785, 2892252, 134513196, 2903264, 2899956, 134513760, 134513424, 134513771, 2899956}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于result[]数组也没有进行初始化操作，数组中的数据都是杂乱无章的。继续利用```s```或者```n```命令往下走，然后用print(简写为p)打印出变量sum的值：</span><br></pre></td></tr></table></figure></p>
<p>(gdb)<br>12            sum = sum + i;<br>(gdb) p sum<br>$1 = 1218251<br>(gdb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里```sum```值打印已经出错了，可以利用```finish```命令让程序一直运行到从当前函数返回为止或者利用```continue(简写为c)```命令运行到程序结束，然后修改源代码。</span><br></pre></td></tr></table></figure></p>
<p>(gdb) finish<br>Run till exit from #0  add (low=1, high=10) at gdb.c:12<br>0x08048409 in main (argc=1, argv=0xbffff324) at gdb.c:18<br>18        result[0] = add(1,10);<br>Value returned is $2 = 1218306<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">result[0] is 1218306</span><br><span class="line">result[1] is 1223356 </span><br><span class="line"></span><br><span class="line">Program exited normally</span><br></pre></td></tr></table></figure></p>
<p>也可以利用<figure class="highlight plain"><figcaption><span>var 变量=XX```命令进行变量赋值，运行调试程序，验证思路正确性。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">(gdb) set var sum=0</span><br><span class="line">(gdb) s</span><br><span class="line">11	    for(i=low;i&lt;=high;i++)</span><br><span class="line">(gdb) </span><br><span class="line">12	        sum = sum + i;</span><br><span class="line">(gdb) p sum</span><br><span class="line">$10 = 1</span><br><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  add (low=1, high=10) at gdb.c:12</span><br><span class="line">0x08048409 in main (argc=1, argv=0xbffff324) at gdb.c:18</span><br><span class="line">18	    result[0] = add(1,10);</span><br><span class="line">Value returned is $11 = 55</span><br></pre></td></tr></table></figure></p>
<p>从运行结果来看，当把<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###### 3、断点调试</span><br><span class="line">断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后可以一步一步往下调试。断点调试是一种非常有效的调试方法。本小节将通过例子进行断点调试的学习。</span><br></pre></td></tr></table></figure></p>
<p>#include <stdio.h><br>int main(void)<br>{<br>    int sum = 0, i = 0;<br>    char input[5];<br>    while (1) {<br>        scanf(“%s”, input);<br>        for (i = 0; input[i] != ‘\0’; i++)<br>            sum = sum*10 + input[i] - ‘0’;  //字符型’2’-‘0’的ASCII码正好是整形2<br>        printf(“input=%d\n”, sum);</stdio.h></p>
<pre><code>}
return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序运行结果如下：</span><br></pre></td></tr></table></figure></p>
<p>[peterwang@localhost gdb]$ ./gdb_breakpoint<br>123<br>input=123<br>123<br>input=123123<br>^C<br>[peterwang@localhost gdb]$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以看到程序运行第一次输入结果是正确的，第二次输入123，却输出123123（例子只是单纯的进行gdb测试，高手勿喷），利用``` gcc -g gdb_breakpoint.c -o gdb_breakpoint```编译该代码，运行```./gdb gdb_breadpoint```并执行```start```命令</span><br></pre></td></tr></table></figure></p>
<p>[peterwang@localhost gdb]$ gdb gdb_breakpoint<br>GNU gdb (GDB) Red Hat Enterprise Linux (7.2-83.el6)<br>Copyright (C) 2010 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later <a href="http://gnu.org/licenses/gpl.html" target="_blank" rel="external">http://gnu.org/licenses/gpl.html</a><br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.  Type “show copying”<br>and “show warranty” for details.<br>This GDB was configured as “i686-redhat-linux-gnu”.<br>For bug reporting instructions, please see:<br><a href="http://www.gnu.org/software/gdb/bugs/" target="_blank" rel="external">http://www.gnu.org/software/gdb/bugs/</a>…<br>Reading symbols from /home/peterwang/TestProgram/gdb/gdb_breakpoint…done.<br>(gdb) start<br>Temporary breakpoint 1 at 0x804841d: file gdb_breakpoint.c, line 10.<br>Starting program: /home/peterwang/TestProgram/gdb/gdb_breakpoint </p>
<p>Temporary breakpoint 1, main () at gdb_breakpoint.c:10<br>10        int sum = 0, i = 0;<br>(gdb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行```next(n)```命令，根据之前的经验，需要重点怀疑```sum```和```input数组```的值的变化，可以利用```display sum/input```命令时刻观察值的变化。通过```undisplay 编号```进行取消跟踪显示。</span><br></pre></td></tr></table></figure></p>
<p>(gdb) display sum<br>1: sum = 0<br>(gdb) display input<br>2: input = “\b`\203\004\b”<br>(gdb) n<br>123<br>14            for (i = 0; input[i] != ‘\0’; i++)<br>2: input = “123\000\b”<br>1: sum = 0<br>(gdb)<br>15                sum = sum<em>10 + input[i] - ‘0’;<br>2: input = “123\000\b”<br>1: sum = 0<br>(gdb)<br>14            for (i = 0; input[i] != ‘\0’; i++)<br>2: input = “123\000\b”<br>1: sum = 1<br>(gdb)<br>15                sum = sum</em>10 + input[i] - ‘0’;<br>2: input = “123\000\b”<br>1: sum = 1<br>(gdb)<br>14            for (i = 0; input[i] != ‘\0’; i++)<br>2: input = “123\000\b”<br>1: sum = 12<br>(gdb)<br>15                sum = sum*10 + input[i] - ‘0’;<br>2: input = “123\000\b”<br>1: sum = 12<br>(gdb)<br>14            for (i = 0; input[i] != ‘\0’; i++)<br>2: input = “123\000\b”<br>1: sum = 123<br>(gdb)<br>16            printf(“input=%d\n”, sum);<br>2: input = “123\000\b”<br>1: sum = 123<br>(gdb)<br>input=123<br>18        }<br>2: input = “123\000\b”<br>1: sum = 123<br>(gdb)<br>123<br>14            for (i = 0; input[i] != ‘\0’; i++)<br>2: input = “123\000\b”<br>1: sum = 123<br>(gdb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以看出第14步第二次输入数据的时候```sum=123```这显然不符合程序的本意，可以推断出问题出在```sum```变量在每次```while(1)```的时候没有进行赋0操作。问题是找出来了，可是可以看出这样调试效率不是很高，我们可以利用```break命令(简写为b)```设置断点。```break```命令可以跟行数也可以跟函数名设置断点。利用```info命令(简写为i) breakpoints```查看当前的断点信息，利用```delete breakpoints 断点编号(info 出来的编号)```进行断点删除，```delete breakpoints```命令是删除所有断点，如果一个断点我们暂时不想使用可以利用```disable breakpoints 断点编号```直接禁用，利用```enbale  断点编号```启用断点。</span><br></pre></td></tr></table></figure></p>
<p>(gdb) l<br>5        &gt; Created Time: Tue 12 Apr 2016 05:21:15 PM CST<br>6     <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>7    #include <stdio.h><br>8    int main(void)<br>9    {<br>10        int sum = 0, i = 0;<br>11        char input[5];<br>12        while (1) {<br>13            printf(“请输入一个6位以下的数字:\n”);<br>14            scanf(“%s”, input);<br>(gdb)<br>15            for (i = 0; input[i] != ‘\0’; i++)<br>16                sum = sum*10 + input[i] - ‘0’;<br>17            printf(“input=%d\n”, sum);<br>18<br>19        }<br>20        return 0;<br>21    }<br>(gdb) b 15<br>Breakpoint 2 at 0x804847e: file gdb_breakpoint.c, line 15.<br>(gdb) c<br>Continuing.<br>请输入一个6位以下的数字:<br>123</stdio.h></p>
<p>Breakpoint 2, main () at gdb_breakpoint.c:15<br>15            for (i = 0; input[i] != ‘\0’; i++)<br>2: input = “123\000\b”<br>1: sum = 0<br>(gdb) c<br>Continuing.<br>input=123<br>请输入一个6位以下的数字:<br>123</p>
<p>Breakpoint 2, main () at gdb_breakpoint.c:15<br>15            for (i = 0; input[i] != ‘\0’; i++)<br>2: input = “123\000\b”<br>1: sum = 123<br>(gdb) </p>
<p>(gdb) info breakpoints<br>Num     Type           Disp Enb Address    What<br>2       breakpoint     keep y   0x0804847e in main at gdb_breakpoint.c:15<br>    breakpoint already hit 2 times<br>(gdb) disable breakpoints 2<br>(gdb) enable 2<br>(gdb) delete breakpoints<br>Delete all breakpoints? (y or n) y<br>(gdb) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们在程序的15行设置断点，利用```continue(c)```命令执行程序，直到断点处停下，可以看到第二次输入123的时候，```sum```的值为123，按照程序逻辑这时候```sum```应该为0，这里也可以判断出，```while(1)```中缺少了```sum```的赋0操作。  </span><br><span class="line">```break```命令非常灵活，我们还可以利用条件语句设置断点，比如```break 15 if sum!=0```仅当sum!=0的时候在15行设置断点，然后利用```run(r)```命令从头进行调试。</span><br></pre></td></tr></table></figure>
<p>gdb) b 15 if sum!=0<br>Breakpoint 2 at 0x804847e: file gdb_breakpoint.c, line 15.<br>(gdb) run<br>The program being debugged has been started already.<br>Start it from the beginning? (y or n) y<br>Starting program: /home/peterwang/TestProgram/gdb/gdb_breakpoint<br>请输入一个6位以下的数字:<br>123<br>input=123<br>请输入一个6位以下的数字:<br>123</p>
<p>Breakpoint 2, main () at gdb_breakpoint.c:15<br>15            for (i = 0; input[i] != ‘\0’; i++)<br>2: input = “123\000\b”<br>1: sum = 123<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###### 3、观察点调试</span><br><span class="line">根据上一小节，我们知道在```while(1)```中加入```sum=0```程序可以得到正确的结果，可是如果```scanf```输入数组越界会是什么情况呢？</span><br></pre></td></tr></table></figure></p>
<p>[peterwang@localhost gdb]$ ./gdb_breakpoint<br>请输入一个5位以下的数字:<br>123<br>input=123<br>请输入一个5位以下的数字:<br>12<br>input=12<br>请输入一个5位以下的数字:<br>12345<br>input=12345090<br>请输入一个5位以下的数字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以看到输出了一个诡异的结果，进入```gdb```调试，利用```x/7 input```命令查看```input```数组值的变化情况，```x```代表打印指定存储单元的内容，```7```代表打印7组。</span><br></pre></td></tr></table></figure>
<p>(gdb) start<br>The program being debugged has been started already.<br>Start it from the beginning? (y or n) y<br>Temporary breakpoint 2 at 0x804844d: file gdb_breakpoint.c, line 10.<br>Starting program: /home/peterwang/TestProgram/gdb/gdb_breakpoint </p>
<p>Temporary breakpoint 2, main () at gdb_breakpoint.c:10<br>10        int sum = 0, i = 0;<br>(gdb) n<br>13            sum = 0;<br>(gdb)<br>14            printf(“请输入一个5位以下的数字:\n”);<br>(gdb)<br>请输入一个5位以下的数字:<br>15            scanf(“%s”, input);<br>(gdb)<br>12345<br>16            for (i = 0; input[i] != ‘\0’; i++)<br>(gdb) p input<br>$2 = “12345”<br>(gdb) x/7 input<br>0xbffff253:    0x31    0x32    0x33    0x34    0x35    0x00    0x00<br>(gdb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们知道断点是当程序执行到某一代码行时中断，而观察点是当程序访问某个存储单</span><br><span class="line">元时中断，如果我们不知道某个存储单元是在哪里被改动的，这时候观察点尤其有</span><br><span class="line">用。用```watch```命令设置观察点，跟踪input[4]后面那个字节（可以用input[5]表示，虽然这是访问越界）,利用 ```info(i) watchpoints```查询当前观察点。</span><br></pre></td></tr></table></figure></p>
<p>(gdb) start<br>Temporary breakpoint 1 at 0x804844d: file gdb_breakpoint.c, line 10.<br>Starting program: /home/peterwang/TestProgram/gdb/gdb_breakpoint </p>
<p>Temporary breakpoint 1, main () at gdb_breakpoint.c:10<br>10        int sum = 0, i = 0;<br>(gdb) n<br>13            sum = 0;<br>(gdb)<br>14            printf(“请输入一个5位以下的数字:\n”);<br>(gdb)<br>请输入一个5位以下的数字:<br>15            scanf(“%s”, input);<br>(gdb)<br>1234<br>16            for (i = 0; input[i] != ‘\0’; i++)<br>(gdb) watch input[4]<br>Hardware watchpoint 2: input[4]<br>(gdb) c<br>Continuing.<br>input=1234<br>请输入一个5位以下的数字:<br>12345<br>Hardware watchpoint 2: input[4]</p>
<p>Old value = 0 ‘\000’<br>New value = 53 ‘5’<br>0x00183f74 in _IO_vfscanf_internal (s=0x35, format=0x400 <address 0x400="" out="" of="" bounds="">, argptr=0x4850000 <address 0x4850000="" out="" of="" bounds="">, errp=0x8) at vfscanf.c:1031<br>1031                  *str++ = c;<br>(gdb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">###### 4、段错误调试</span><br></pre></td></tr></table></figure></address></address></p>
<p>#include <stdio.h><br>int main(void)<br>{<br>    int man = 0;<br>    scanf(“%d”, man);<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用命令```gcc -g gdb_segdefault.c -o gdb_segdefault```编译这段程序，运行出现段错误提示。</span><br></pre></td></tr></table></figure></stdio.h></p>
<p>[peterwang@localhost gdb]$ ./gdb_segdefault<br>123<br>Segmentation fault (core dumped)<br>[peterwang@localhost gdb]$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进入```gdb```调试</span><br></pre></td></tr></table></figure></p>
<p>(gdb) start<br>Temporary breakpoint 1 at 0x80483ed: file gdb_segdefault.c, line 10.<br>Starting program: /home/peterwang/TestProgram/gdb/gdb_segdefault </p>
<p>Temporary breakpoint 1, main () at gdb_segdefault.c:10<br>10        int man = 0;<br>(gdb) n<br>11        scanf(“%d”, man);<br>(gdb)<br>123</p>
<p>Program received signal SIGSEGV, Segmentation fault.<br>0x00182aa5 in _IO_vfscanf_internal (s=0x333231, format=0xffffffff <address 0xffffffff="" out="" of="" bounds="">, argptr=0x0, errp=0xb) at vfscanf.c:1772<br>1772                <em>ARG (unsigned int </em>) = (unsigned int) num.ul;<br>(gdb) bt</address></p>
<p>#0  0x00182aa5 in _IO_vfscanf_internal (s=0x333231, format=0xffffffff <address 0xffffffff="" out="" of="" bounds="">, argptr=0x0, errp=0xb) at vfscanf.c:1772</address></p>
<p>#1  0x0018f939 in __isoc99_scanf (format=0x80484e4 “%d”) at isoc99_scanf.c:37</p>
<p>#2  0x0804840a in main () at gdb_segdefault.c:11<br>(gdb)<br><code>可以看到，</code>gdb<code>提示</code>Program received signal SIGSEGV, Segmentation fault.<code>错误，利用</code>bt<code>命令查看</code>_IO_vfscanf_internal<code>是被</code>__isoc99_scanf<code>调用，可以确定</code>main<code>函数中的</code>scanf<code>出现问题，可以检查出</code>scanf<code>函数中忘记加入</code>&amp;```导致段错误。</p>
<hr>
<p>还有一种经常发生的段错误，算是一条规律，如果<code>某个函数的局部变量发生访问越界</code>，有可能并不立即产生段错误，而是在函数返回时产生<code>段错误</code>。</p>
<hr>
<h6 id="附录（常用的gdb命令）"><a href="#附录（常用的gdb命令）" class="headerlink" title="附录（常用的gdb命令）"></a>附录（常用的gdb命令）</h6><p><strong>一.基本命令</strong></p>
<hr>
<p>1）进入GDB　　#gdb test<br>test是要调试的程序，由gcc test.c -g -o test生成。进入后提示符变为(gdb)</p>
<hr>
<p>2）查看源码　　(gdb) l<br>源码会进行行号提示。如果需要查看在其他文件中定义的函数，在l后加上函数名即可定位到这个函数的定义及查看附近的其他源码。或者：使用断点或单步运行，到某个函数处使用s进入这个函数。</p>
<hr>
<p>3）启动gdb，并且分屏显示源代码　　gdb -tui<br>这样,使用了’-tui’选项，启动可以直接将屏幕分成两个部分，上面显示源代码，比用list方便多了。这时候使用上下方向键可以查看源代码,想要命令行使用上下键就用[Ctrl]n和[Ctrl]p</p>
<hr>
<p>4）设置断点　　(gdb) b 6<br>这样会在运行到源码第6行时停止，可以查看变量的值、堆栈情况等；这个行号是gdb的行号。</p>
<hr>
<p>5）查看断点处情况　　(gdb) info b<br>可以键入”info b”来查看断点处情况，可以设置多个断点；</p>
<hr>
<p>6）运行代码　　(gdb) r</p>
<hr>
<p>7）显示变量值　　(gdb) p n<br>在程序暂停时，键入”p 变量名”(print)即可；<br>GDB在显示变量值时都会在对应值之前加上”$N”标记，它是当前变量值的引用标记，以后若想再次引用此变量，就可以直接写作”$N”，而无需写冗长的变量名；  </p>
<hr>
<p>8）观察变量　　(gdb) watch n<br>在某一循环处，往往希望能够观察一个变量的变化情况，这时就可以键入命令”watch”来观察变量的变化情况，GDB在”n”设置了观察点；  </p>
<hr>
<p>9）单步运行（不进入函数）　　(gdb) n</p>
<hr>
<p>10）单步运行（进入函数）　　(gdb) s</p>
<hr>
<p>11）程序继续运行　　(gdb) c<br>使程序继续往下运行，直到再次遇到断点或程序结束；</p>
<h2 id=""><a href="#" class="headerlink" title="　　"></a>　　</h2><p>12）退出GDB　　(gdb) q</p>
<hr>
<p><strong>二.断点调试</strong>  </p>
<hr>
<p>break + 设置断点的行号　　break n　　　　　　在n行处设置断点</p>
<hr>
<p>tbreak + 行号或函数名　　 tbreak n/func　　　　设置临时断点，到达后被自动删除</p>
<hr>
<p>break + filename + 行号　　break main.c:10　　用于在指定文件对应行设置断点</p>
<hr>
<p>break + <0x...>　　break 0x3400a　　　　　　用于在内存某一位置处暂停</0x...></p>
<hr>
<p>break + 行号 + if + 条件　　break 10 if i==3　　　用于设置条件断点，在循环中使用非常方便</p>
<hr>
<p>info breakpoints/watchpoints [n]　　info break　　n表示断点号，查看断点/观察点的情况 </p>
<hr>
<p>clear + 要清除的断点行号　　clear 10　　　　用于清除对应行的断点，要给出断点的行号，清除时GDB会给出提示</p>
<hr>
<p>delete + 要清除的断点编号　　delete 3　　　　用于清除断点和自动显示的表达式的命令，要给出断点的编号，清除时GDB不会给出任何提示</p>
<hr>
<p>disable/enable + 断点编号　　disable 3　　　　让所设断点暂时失效/使能，如果要让多个编号处的断点失效/使能，可将编号之间用空格隔开</p>
<hr>
<p>awatch/watch + 变量　　awatch/watch i　　　　设置一个观察点，当变量被读出或写入时程序被暂停 </p>
<hr>
<p>rwatch + 变量　　　　　　rwatch i　　　　　　　　设置一个观察点，当变量被读出时，程序被暂停 </p>
<hr>
<p>catch　　　　　　　　　　　　　　　　　　设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常 </p>
<hr>
<p>tcatch　　　　　　　　　　　　　　　　　　只设置一次捕捉点，当程序停住以后，应点被自动删除</p>
<hr>
<p><strong>三.数据命令</strong></p>
<hr>
<p>display +表达式　　display a　　用于显示表达式的值，每当程序运行到断点处都会显示表达式的值 </p>
<hr>
<p>info display　　　　　　用于显示当前所有要显示值的表达式的情况 </p>
<hr>
<p>delete + display 编号　　delete<br>3　　用于删除一个要显示值的表达式，被删除的表达式将不被显示</p>
<hr>
<p>disable/enable + display 编号　　disable/enable 3　　使一个要显示值的表达式暂时失效/使能 </p>
<hr>
<p>undisplay + display 编号　　undisplay 3　　用于结束某个表达式值的显示</p>
<hr>
<p>whatis + 变量　　whatis i　　显示某个表达式的数据类型</p>
<hr>
<p>print(p) + 变量/表达式　　p n　　用于打印变量或表达式的值</p>
<hr>
<p>set  变量 = 变量值　　set i = 3　　改变程序中某个变量的值<br>　　在使用print命令时，可以对变量按指定格式进行输出，其命令格式为print /变量名 + 格式<br>　　其中常用的变量格式：x：十六进制；d：十进制；u：无符号数；o：八进制；c：字符格式；f：浮点数。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="　　"></a>　　</h2><p><strong>四.调试运行环境相关命令</strong></p>
<hr>
<p>set args　　set args arg1 arg2　　设置运行参数</p>
<hr>
<p>show args　　show args　　参看运行参数</p>
<hr>
<p>set width + 数目　　set width 70　　设置GDB的行宽</p>
<hr>
<p>cd + 工作目录　　cd ../　　切换工作目录</p>
<hr>
<p>run　　r/run　　程序开始执行</p>
<hr>
<p>step(s)　　s　　进入式（会进入到所调用的子函数中）单步执行，进入函数的前提是，此函数被编译有debug信息</p>
<hr>
<p>next(n)　　n　　非进入式（不会进入到所调用的子函数中）单步执行</p>
<hr>
<p>finish　　finish　　一直运行到函数返回并打印函数返回时的堆栈地址和返回值及参数值等信息</p>
<hr>
<p>until + 行数　　u 3　　运行到函数某一行 </p>
<hr>
<p>continue(c)　　c　　执行到下一个断点或程序结束 </p>
<hr>
<p>return &lt;返回值&gt;　　return 5　　改变程序流程，直接结束当前函数，并将指定值<br>返回</p>
<hr>
<p>call + 函数　　call func　　在当前位置执行所要运行的函数</p>
<hr>
<p><strong>五.堆栈相关命令</strong></p>
<hr>
<p>backtrace/bt　　bt　　用来打印栈帧指针，也可以在该命令后加上要打印的栈帧指针的个数，查看程序执行到此时，是经过哪些函数呼叫的程序，程序“调用堆栈”是当前函数之前的所有已调用函数的列表（包括当前函数）。每个函数及其变量都被分配了一个“帧”，最近调用的函数在 0 号帧中（“底部”帧）</p>
<hr>
<p>frame　　frame 1　　用于打印指定栈帧</p>
<hr>
<p>info reg　　info reg　　查看寄存器使用情况</p>
<hr>
<p>info stack　　info stack　　查看堆栈使用情况</p>
<hr>
<p>up/down　　up/down　　跳到上一层/下一层函数</p>
<hr>
<p><strong>六.跳转执行</strong></p>
<hr>
<p>jump  指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。相当于改变了PC寄存器内容，堆栈内容并没有改变，跨函数跳转容易发生错误。</p>
<hr>
<p><strong>七.信号命令</strong></p>
<hr>
<p>signal 　　signal SIGXXX 　　产生XXX信号，如SIGINT。一种速查Linux查询信号的方法：# kill -l</p>
<hr>
<p>handle 　　在GDB中定义一个信号处理。信号可以以SIG开头或不以SIG开头，可以用定义一个要处理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其可以是以下几种关键字的一个或多个：</p>
<hr>
<p>nostop/stop<br>　　　　当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号/GDB会停住你的程序  </p>
<h2 id="-2"><a href="#-2" class="headerlink" title="　　　　"></a>　　　　</h2><p>print/noprint<br>　　　　当被调试的程序收到信号时，GDB会显示出一条信息/GDB不会告诉你收到信号的信息 </p>
<hr>
<p>info signals<br>　　info handle<br>　　　　可以查看哪些信号被GDB处理，并且可以看到缺省的处理方式<br>　　single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。</p>
<h2 id="-3"><a href="#-3" class="headerlink" title="　　"></a>　　</h2><p>8.运行Shell命令<br>　　如(gdb)shell ls来运行ls。</p>
<h2 id="-4"><a href="#-4" class="headerlink" title="　　"></a>　　</h2><p><strong>九.更多程序运行选项和调试</strong></p>
<hr>
<p>1、程序运行参数。<br>　　set args 可指定运行时参数。（如：set args 10 20 30 40 50）<br>　　show args 命令可以查看设置好的运行参数。 </p>
<h2 id="-5"><a href="#-5" class="headerlink" title="　　"></a>　　</h2><p>2、运行环境。<br>　　path 可设定程序的运行路径。<br>　　show paths 查看程序的运行路径。<br>　　set environment varname [=value] 设置环境变量。如：set env USER=hchen<br>　　show environment [varname] 查看环境变量。 </p>
<h2 id="-6"><a href="#-6" class="headerlink" title="　　"></a>　　</h2><p>3、工作目录。<br>　　cd　　  相当于shell的cd命令。<br>　　pwd　　显示当前的所在目录。 </p>
<h2 id="-7"><a href="#-7" class="headerlink" title="　　"></a>　　</h2><p>4、程序的输入输出。<br>　　info terminal 显示你程序用到的终端的模式。<br>　　使用重定向控制程序输出。如：run &gt; outfile<br>　　tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb  </p>
<h2 id="-8"><a href="#-8" class="headerlink" title="　　"></a>　　</h2><p>5、调试已运行的程序<br>两种方法：<br>　　(1)在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用gdb PID格式挂接正在运行的程序。<br>　　(2)先用gdb 关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。  </p>
<h2 id="-9"><a href="#-9" class="headerlink" title="　　"></a>　　</h2><p>6、暂停 / 恢复程序运行<br>当进程被gdb停住时，你可以使用info program来查看程序的是否在运行，进程号，被暂停的原因。 在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops），如果要恢复程序运行，可以使用c或是continue命令。</p>
<hr>
<p>7、线程（Thread Stops）<br>如果程序是多线程，可以定义断点是否在所有的线程上，或是在某个特定的线程。<br>　　break thread<br>　　break thread if …<br>　　linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是GDB分配的，可以通过“info threads”命令来查看正在运行程序中的线程信息。如果不指定thread 则表示断点设在所有线程上面。还可以为某线程指定断点条件。<br>　　如： (gdb) break frik.c:13 thread 28 if bartab &gt; lim<br>当你的程序被GDB停住时，所有的运行线程都会被停住。这方便查看运行程序的总体情况。而在你恢复程序运行时，所有的线程也会被恢复运行。</p>
<hr>
<h6 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h6><p>《Linux C编程一站式学习》<br><a href="">http://www.jb51.net/article/36393.htm</a><br><a href="">http://blog.chinaunix.net/uid-9525959-id-2001805.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux学习总结/">Linux学习总结</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="w-个人随笔-三月份" class="article article-type-w" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/01/个人随笔-三月份/" class="article-date">
  	<time datetime="2016-04-01T13:06:16.000Z" itemprop="datePublished">2016-04-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/01/个人随笔-三月份/">个人随笔-三月份</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>明天就是清明假期了，三月份匆匆的从身边走过，让人来不及挽留。转眼间自己来北京，当着传说中的北漂也半个多月了，这期间的感悟和收获颇多。</p>
<hr>
<h3 id="现在我正听着熟悉的音乐，回顾着这段时间来的的点点滴滴。"><a href="#现在我正听着熟悉的音乐，回顾着这段时间来的的点点滴滴。" class="headerlink" title="现在我正听着熟悉的音乐，回顾着这段时间来的的点点滴滴。"></a>现在我正听着熟悉的音乐，回顾着这段时间来的的点点滴滴。</h3><hr>
<h4 id="初来乍到，稍感不适"><a href="#初来乍到，稍感不适" class="headerlink" title="初来乍到，稍感不适"></a>初来乍到，稍感不适</h4><p>还记得刚来北京时候的不适应和孤独无助，好在之前表哥已经给我租好了房子，房子价格还好，每个月750块钱不是很贵，想到了周围的环境应该不是很好，自己本身对房子也没有什么特别的要求，属于自己的小空间就可以了。可是来到之后还是有点小小的失落，在房子去主路的唯一的一条小路上布满了垃圾，用晓云的话来说就是垃圾街，因为面试的原因，她比我先见到了房子。好吧，当时心里就想现在还好，如果是夏天或者下雨的话，不知道会成什么样子。。不过直到现在北京也没有一场雨。。阴天都不多，一片春意盎然的气派，到底垃圾街能成为啥样子，只能以后再看效果了。</p>
<p>房子是一栋连体的三层小楼，房子门口树立着一个巨大的锅炉（巨大有点夸张，相对于房子的高度来说已经相当高了，哈哈），房子的大门需要用小门禁卡刷卡进出，这一点还是不错的，相对来说安全不少，而且四周都布有摄像头。。对于这种房子来说，最大的好处就是便宜了，也只剩这一个优点了。。谁让咱是穷屌丝北漂一族呢。。心酸。。屋子不是很大，基本常年不会见到sunshine这个东西，对于阳光的渴望相当强烈了。。说实话，刚进屋子的时候，并不是很满意，屋子里的三块地板砖已经烂了。。很不好看，而且屋子也不够温馨，还有蜘蛛网这种东西，话说，我已经好久没有见到有蜘蛛网的房子了。。然后就是乱七八糟糟七八乱的一顿收拾。。好在东西不多，很快东西就整理完毕了。。。</p>
<p>东西收拾的差不多，出去买了一些日用品，乱七八糟的一大堆，以前在学校从来不用管的东西，在这全部都得花钱买，好在这边东西也不算贵，大约大概跟济大夜市差不多价格吧。。这也是我们选择在这住的重要原因！！！还有一个好处。。快递真的非常方面，圆通，申通，顺丰，京东，邮政都可以送到家的周围几百米。。好吧。。还是将目前还算温馨的小窝的照片保存一下吧。。几年后的我是不是会怀念这时候艰苦的岁月呢。。鬼知道呢。。<br><img src="http://7xsibp.com2.z0.glb.clouddn.com/c14deabcfcee94bea706da05c4a09f0b4b2dfb72.jpg" alt="两张有大作用的小桌子"><br><img src="http://7xsibp.com2.z0.glb.clouddn.com/IMG_20160315_140029.jpg" alt="不是很大的窗户"><br><img src="http://7xsibp.com2.z0.glb.clouddn.com/IMG_20160315_140600.jpg" alt="温馨的小床"><br><img src="http://7xsibp.com2.z0.glb.clouddn.com/IMG_20160315_194247.jpg" alt="到现在也没用过的油烟机"></p>
<p>下边再来说说北京最能让人吐槽的地方，交通拥堵，以前在济南上学，就感觉济南天天堵堵的，可是来到北京才知道什么才是堵车，我住的地方在五环到六环之间，距离北五环大约至少得有8到10公里，自己骑车子计算过。。这边就是一个村。。可是村里唯一的一条主干道天天堵得嗷嗷叫。。更不要说南北主干道立汤路了，立汤路估计一天不堵车的时候根本不多。。天天堵得嗷嗷叫。。早高峰晚高峰更严重了，整天听着他们嗷嗷按喇叭，当然堵车也有人多的原因，无论他们如何按喇叭，路人依旧往前走，无视他们的存在。。对了。。忘了介绍住的地方了。。我住在北京北边的天通苑。。这边是天通苑的最北边，准确的说不属于天通苑社区。。天通苑社区是全世界最大的社区。。据不完全统计，这边共居住了70多万人。。可以想象唯一的地铁5号线需要多大的运力，才能把那么多人天天来回拉来拉去。。我需要从天通苑北上地铁，这是地铁五号线的终点站，一般终点站都是比较拥挤的，之前听过各种人说地铁多么挤。。只有亲自经历过才知道。。记得第一天上班。。真的被惊讶到了。。当时都不知道手往哪里放，随着人群往年走就行，不走都不行，后边的人会推着你走。。确实有一种超能力的感觉。。<br><img src="http://7xsibp.com2.z0.glb.clouddn.com/39b0387d2169cd3fa47c54a9e961d62afd40e506.jpg" alt="地铁人群"></p>
<p>这个是起限流作用的措施。。人群需要从进站口进去，一直走到棚子的西头，然后掉头回来，再掉头回去，这样来来回回走上七八趟才有机会进入安检口。。每天就是这样。。从排队到进安检大约20分钟的时间，前两天感觉很别扭。。后来。。就没有后来了。。慢慢就习惯了。。好吧。。快三点了。。该睡觉去了。。</p>
<h4 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h4><p>4/2/2016 2:55:25 AM 
　　</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/个人感悟/">个人感悟</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Manfred的第一篇个人Blog" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/31/Manfred的第一篇个人Blog/" class="article-date">
  	<time datetime="2016-03-30T17:21:11.000Z" itemprop="datePublished">2016-03-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/31/Manfred的第一篇个人Blog/">Hexo+github创建个人博客总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>太累了。。。清明假期总结一下。。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Manfred Zhao
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>